/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.10).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package org.alfresco.governance.core.handler;

import org.alfresco.governance.core.model.Error;
import org.alfresco.governance.core.model.RMNodeBodyCreateWithRelativePath;
import org.alfresco.governance.core.model.UnfiledRecordFolderAssociationPaging;
import org.alfresco.governance.core.model.UnfiledRecordFolderBodyUpdate;
import org.alfresco.governance.core.model.UnfiledRecordFolderEntry;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;

@Api(value = "UnfiledRecordFolders")
public interface UnfiledRecordFoldersApi {

    @ApiOperation(value = "Create a record or an unfiled record folder", nickname = "createUnfiledRecordFolderChildren", notes = "Create a record or an unfiled record folder as a primary child of **unfiledRecordFolderId**.  You can set the **autoRename** boolean field to automatically resolve name clashes. If there is a name clash, then the API method tries to create a unique name using an integer suffix.  This endpoint supports both JSON and multipart/form-data (file upload).  **Using multipart/form-data**  Use the **filedata** field to represent the content to upload, for example, the following curl command will create a node with the contents of test.txt in the test user's home folder.  ```curl -utest:test -X POST host:port/alfresco/api/-default-/public/gs/versions/1/unfiled-record-folders/{unfiledRecordFolderId}/children -F filedata=@test.txt```  This API method also supports record and unfiled record folder creation using application/json.  You must specify at least a **name** and **nodeType**.  You can create a non-electronic record like this: ```JSON {   \"name\":\"My Non-electronic Record\",   \"nodeType\":\"rma:nonElectronicDocument\",   \"properties\":     {       \"cm:description\":\"My Non-electronic Record Description\",       \"cm:title\":\"My Non-electronic Record Title\",       \"rma:box\":\"My Non-electronic Record Box\",       \"rma:file\":\"My Non-electronic Record File\",       \"rma:numberOfCopies\":1,       \"rma:physicalSize\":30,       \"rma:shelf\":\"My Non-electronic Record Shelf\",       \"rma:storageLocation\":\"My Non-electronic Record Location\"     } } ```  You can create an empty electronic record like this: ```JSON {   \"name\":\"My Electronic Record\",   \"nodeType\":\"cm:content\" } ```  You can create an unfiled record folder like this: ```JSON {   \"name\": \"My Unfiled Record Folder\",   \"nodeType\": \"rma:unfiledRecordFolder\",   \"properties\":   {     \"cm:title\": \"My Unfiled Record Folder Title\"   } } ```  Any missing aspects are applied automatically. You can set aspects explicitly, if needed, using an **aspectNames** field.  **Note:** You can create more than one child by specifying a list of nodes in the JSON body. For example, the following JSON body creates a record and an unfiled record folder inside the specified **unfiledRecordFolderId**: ```JSON [   {     \"name\":\"My Record\",     \"nodeType\":\"cm:content\"   },   {     \"name\":\"My Unfiled Record Folder\",     \"nodeType\":\"rma:unfiledRecordFolder\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {           ...         }       }     ]   } } ``` ", response = UnfiledRecordFolderAssociationPaging.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-record-folders", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Successful response", response = UnfiledRecordFolderAssociationPaging.class),
        @ApiResponse(code = 400, message = "Invalid parameter: **unfiledRecordFolderId** is not a valid format or **unfiledRecordFolderId** is invalid "),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to add children to **unfiledRecordFolderId**"),
        @ApiResponse(code = 404, message = "**unfiledRecordFolderId** does not exist"),
        @ApiResponse(code = 409, message = "New name clashes with an existing node in the current parent container"),
        @ApiResponse(code = 422, message = "Model integrity exception, including node name with invalid characters") })
    @RequestMapping(value = "/unfiled-record-folders/{unfiledRecordFolderId}/children",
        produces = "application/json", 
        consumes = "application/json",
        method = RequestMethod.POST)
    ResponseEntity<UnfiledRecordFolderAssociationPaging
> createUnfiledRecordFolderChildren(


@ApiParam(value = "The identifier of an unfiled record folder.",required=true) @PathVariable("unfiledRecordFolderId") String
 unfiledRecordFolderId



,


@ApiParam(value = "The node information to create." ,required=true )  @Valid @RequestBody RMNodeBodyCreateWithRelativePath nodeBodyCreate

,

@ApiParam(value = "If true, then  a name clash will cause an attempt to auto rename by finding a unique name using an integer suffix. ") @Valid @RequestParam(value = "autoRename", required = false) Boolean
 autoRename




,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * path ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);


    @ApiOperation(value = "Delete an unfiled record folder. Deleted file plan components cannot be recovered, they are deleted permanently.", nickname = "deleteUnfiledRecordFolder", notes = "Deletes the unfiled record folder **unfiledRecordFolderId**. ", authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-record-folders", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "Successful response"),
        @ApiResponse(code = 400, message = "Invalid parameter: **unfiledRecordFolderId** is not a valid format "),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to delete **unfiledRecordFolderId**"),
        @ApiResponse(code = 404, message = "**unfiledRecordFolderId** does not exist"),
        @ApiResponse(code = 409, message = "**unfiledRecordFolderId** is locked and cannot be deleted"),
        @ApiResponse(code = 200, message = "Unexpected error", response = Error.class) })
    @RequestMapping(value = "/unfiled-record-folders/{unfiledRecordFolderId}",
        produces = "application/json", 
        consumes = "",
        method = RequestMethod.DELETE)
    ResponseEntity<Void
> deleteUnfiledRecordFolder(


@ApiParam(value = "The identifier of an unfiled record folder.",required=true) @PathVariable("unfiledRecordFolderId") String
 unfiledRecordFolderId



);


    @ApiOperation(value = "Get the unfiled record folder", nickname = "getUnfiledRecordFolder", notes = "Gets information for unfiled record folder id **unfiledRecordFolderId**  Mandatory fields and the unfiled record folder's aspects and properties are returned by default.  You can use the **include** parameter (include=allowableOperations) to return additional information. ", response = UnfiledRecordFolderEntry.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-record-folders", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful response", response = UnfiledRecordFolderEntry.class),
        @ApiResponse(code = 400, message = "Invalid parameter: **unfiledRecordFolderId** is not a valid format "),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to read **unfiledRecordFolderId**"),
        @ApiResponse(code = 404, message = "**unfiledRecordFolderId** does not exist"),
        @ApiResponse(code = 200, message = "Unexpected error", response = Error.class) })
    @RequestMapping(value = "/unfiled-record-folders/{unfiledRecordFolderId}",
        produces = "application/json", 
        consumes = "",
        method = RequestMethod.GET)
    ResponseEntity<UnfiledRecordFolderEntry
> getUnfiledRecordFolder(


@ApiParam(value = "The identifier of an unfiled record folder.",required=true) @PathVariable("unfiledRecordFolderId") String
 unfiledRecordFolderId



,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * path ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "Return information on children in the unfiled records container resolved by this path. The path is relative to **unfiledRecordFolderId**. ") @Valid @RequestParam(value = "relativePath", required = false) String
 relativePath




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);


    @ApiOperation(value = "List unfiled record folder's children", nickname = "listUnfiledRecordFolderChildren", notes = "Returns a list of records or unfiled record folders.  Minimal information for each child is returned by default.  You can use the **include** parameter (include=allowableOperations) to return additional information. ", response = UnfiledRecordFolderAssociationPaging.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-record-folders", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful response", response = UnfiledRecordFolderAssociationPaging.class),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to read **unfiledRecordFolderId**"),
        @ApiResponse(code = 404, message = "**unfiledRecordFolderId** does not exist"),
        @ApiResponse(code = 200, message = "Unexpected error", response = Error.class) })
    @RequestMapping(value = "/unfiled-record-folders/{unfiledRecordFolderId}/children",
        produces = "application/json", 
        consumes = "",
        method = RequestMethod.GET)
    ResponseEntity<UnfiledRecordFolderAssociationPaging
> listUnfiledRecordFolderChildren(


@ApiParam(value = "The identifier of an unfiled record folder.",required=true) @PathVariable("unfiledRecordFolderId") String
 unfiledRecordFolderId



,@Min(0)

@ApiParam(value = "The number of entities that exist in the collection before those included in this list.") @Valid @RequestParam(value = "skipCount", required = false) Integer
 skipCount




,@Min(1)

@ApiParam(value = "The maximum number of items to return in the list.") @Valid @RequestParam(value = "maxItems", required = false) Integer
 maxItems




,

@ApiParam(value = "Optionally filter the list. Here are some examples:  *   ```where=(isRecord=true)```  *   ```where=(isUnfiledRecordFolder=false)```  *   ```where=(nodeType='cm:content INCLUDESUBTYPES')``` ") @Valid @RequestParam(value = "where", required = false) String
 where




,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * aspectNames * association * path * properties ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "Return information on children in the unfiled records container resolved by this path. The path is relative to **unfiledRecordFolderId**. ") @Valid @RequestParam(value = "relativePath", required = false) String
 relativePath




,

@ApiParam(value = "Also include **source** (in addition to **entries**) with folder information on the parent node – either the specified parent **unfiledRecordFolderId**, or as resolved by **relativePath**.") @Valid @RequestParam(value = "includeSource", required = false) Boolean
 includeSource




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);


    @ApiOperation(value = "Update an unfiled record folder", nickname = "updateUnfiledRecordFolder", notes = "Updates unfiled record folder **unfiledRecordFolderId**. For example, you can rename a record folder: ```JSON {   \"name\":\"My new name\" } ``` You can also set or update one or more properties: ```JSON {   \"properties\":     {        \"cm:title\":\"New title\",        \"cm:description\":\"New description\"     } } ``` **Note:** if you want to add or remove aspects, then you must use **GET /unfiled-record-folders/{unfiledRecordFolderId}** first to get the complete set of *aspectNames*.  **Note:** Currently there is no optimistic locking for updates, so they are applied in \"last one wins\" order. ", response = UnfiledRecordFolderEntry.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-record-folders", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful response", response = UnfiledRecordFolderEntry.class),
        @ApiResponse(code = 400, message = "Invalid parameter: The update request is invalid or **unfiledRecordFolderId** is not a valid format or **unfiledRecordFolderBodyUpdate** is invalid "),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to update **unfiledRecordFolderId**"),
        @ApiResponse(code = 404, message = "**unfiledRecordFolderId** does not exist"),
        @ApiResponse(code = 409, message = "Updated name clashes with an existing unfiled record folder in the current parent category"),
        @ApiResponse(code = 422, message = "Model integrity exception, including file name with invalid characters"),
        @ApiResponse(code = 200, message = "Unexpected error", response = Error.class) })
    @RequestMapping(value = "/unfiled-record-folders/{unfiledRecordFolderId}",
        produces = "application/json", 
        consumes = "application/json",
        method = RequestMethod.PUT)
    ResponseEntity<UnfiledRecordFolderEntry
> updateUnfiledRecordFolder(


@ApiParam(value = "The identifier of an unfiled record folder.",required=true) @PathVariable("unfiledRecordFolderId") String
 unfiledRecordFolderId



,


@ApiParam(value = "The record folder information to update." ,required=true )  @Valid @RequestBody UnfiledRecordFolderBodyUpdate unfiledRecordFolderBodyUpdate

,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * path ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "Also include **source** (in addition to **entries**) with folder information on the parent node – either the specified parent **unfiledRecordFolderId**, or as resolved by **relativePath**.") @Valid @RequestParam(value = "includeSource", required = false) Boolean
 includeSource




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);

}
