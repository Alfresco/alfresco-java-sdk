/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.10).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package org.alfresco.governance.core.handler;

import org.alfresco.governance.core.model.Error;
import org.alfresco.governance.core.model.RMNodeBodyCreate;
import org.alfresco.governance.core.model.UnfiledContainerAssociationPaging;
import org.alfresco.governance.core.model.UnfiledContainerEntry;
import org.alfresco.governance.core.model.UnfiledRecordContainerBodyUpdate;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;

@Api(value = "UnfiledContainers")
public interface UnfiledContainersApi {

    @ApiOperation(value = "Create a record or an unfiled record folder", nickname = "createUnfiledContainerChildren", notes = "Creates a record or an unfiled record folder as a primary child of **unfiledContainerId**.  You can set the **autoRename** boolean field to automatically resolve name clashes. If there is a name clash, then the API method tries to create a unique name using an integer suffix.  This endpoint supports both JSON and multipart/form-data (file upload).  **Using multipart/form-data**  Use the **filedata** field to represent the content to upload, for example, the following curl command will create a node with the contents of test.txt in the test user's home folder.  ```curl -utest:test -X POST host:port/alfresco/api/-default-/public/gs/versions/1/unfiled-containers/{unfiledContainerId}/children -F filedata=@test.txt```  This API method also supports record and unfiled record folder creation using application/json.  You must specify at least a **name** and **nodeType**.  You can create a non-electronic record like this: ```JSON {   \"name\":\"My Non-electronic Record\",   \"nodeType\":\"rma:nonElectronicDocument\",   \"properties\":     {       \"cm:description\":\"My Non-electronic Record Description\",       \"cm:title\":\"My Non-electronic Record Title\",       \"rma:box\":\"My Non-electronic Record Box\",       \"rma:file\":\"My Non-electronic Record File\",       \"rma:numberOfCopies\":1,       \"rma:physicalSize\":30,       \"rma:shelf\":\"My Non-electronic Record Shelf\",       \"rma:storageLocation\":\"My Non-electronic Record Location\"     } } ```  You can create an empty electronic record: ```JSON {   \"name\":\"My Electronic Record\",   \"nodeType\":\"cm:content\" } ```  You can create an unfiled record folder like this: ```JSON {   \"name\": \"My Unfiled Record Folder\",   \"nodeType\": \"rma:unfiledRecordFolder\",   \"properties\":   {     \"cm:title\": \"My Unfiled Record Folder Title\"   } } ```  Any missing aspects are applied automatically. You can set aspects explicitly, if needed, using an **aspectNames** field.  **Note:** You can create more than one child by specifying a list of nodes in the JSON body. For example, the following JSON body creates a record and an unfiled record folder inside the specified **unfiledContainerId**: ```JSON [   {     \"name\":\"My Record\",     \"nodeType\":\"cm:content\"   },   {     \"name\":\"My Unfiled Record Folder\",     \"nodeType\":\"rma:unfiledRecordFolder\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {           ...         }       }     ]   } } ``` ", response = UnfiledContainerAssociationPaging.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-containers", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Successful response", response = UnfiledContainerAssociationPaging.class),
        @ApiResponse(code = 400, message = "Invalid parameter: **unfiledContainerId** is not a valid format or **unfiledContainerId** is invalid "),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to add children to **unfiledContainerId**"),
        @ApiResponse(code = 404, message = "**unfiledContainerId** does not exist"),
        @ApiResponse(code = 409, message = "New name clashes with an existing node in the current parent container"),
        @ApiResponse(code = 422, message = "Model integrity exception, including node name with invalid characters") })
    @RequestMapping(value = "/unfiled-containers/{unfiledContainerId}/children",
        produces = "application/json", 
        consumes = "application/json",
        method = RequestMethod.POST)
    ResponseEntity<UnfiledContainerAssociationPaging
> createUnfiledContainerChildren(


@ApiParam(value = "The identifier of an unfiled records container. You can use the **-unfiled-** alias.",required=true) @PathVariable("unfiledContainerId") String
 unfiledContainerId



,


@ApiParam(value = "The node information to create." ,required=true )  @Valid @RequestBody RMNodeBodyCreate nodeBodyCreate

,

@ApiParam(value = "If true, then  a name clash will cause an attempt to auto rename by finding a unique name using an integer suffix. ") @Valid @RequestParam(value = "autoRename", required = false) Boolean
 autoRename




,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * path ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);


    @ApiOperation(value = "Get the unfiled records container", nickname = "getUnfiledContainer", notes = "Gets information for unfiled records container **unfiledContainerId**  Mandatory fields and the unfiled records container's aspects and properties are returned by default.  You can use the **include** parameter (include=allowableOperations) to return additional information. ", response = UnfiledContainerEntry.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-containers", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful response", response = UnfiledContainerEntry.class),
        @ApiResponse(code = 400, message = "Invalid parameter: **unfiledContainerId** is not a valid format "),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to read **unfiledContainerId**"),
        @ApiResponse(code = 404, message = "**unfiledContainerId** does not exist"),
        @ApiResponse(code = 200, message = "Unexpected error", response = Error.class) })
    @RequestMapping(value = "/unfiled-containers/{unfiledContainerId}",
        produces = "application/json", 
        consumes = "",
        method = RequestMethod.GET)
    ResponseEntity<UnfiledContainerEntry
> getUnfiledContainer(


@ApiParam(value = "The identifier of an unfiled records container. You can use the **-unfiled-** alias.",required=true) @PathVariable("unfiledContainerId") String
 unfiledContainerId



,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * path ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);


    @ApiOperation(value = "List unfiled record container's children", nickname = "listUnfiledContainerChildren", notes = "Returns a list of records or unfiled record folders.  Minimal information for each child is returned by default.  You can use the **include** parameter (include=allowableOperations) to return additional information. ", response = UnfiledContainerAssociationPaging.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-containers", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful response", response = UnfiledContainerAssociationPaging.class),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to read **unfiledContainerId**"),
        @ApiResponse(code = 404, message = "**unfiledContainerId** does not exist"),
        @ApiResponse(code = 200, message = "Unexpected error", response = Error.class) })
    @RequestMapping(value = "/unfiled-containers/{unfiledContainerId}/children",
        produces = "application/json", 
        consumes = "",
        method = RequestMethod.GET)
    ResponseEntity<UnfiledContainerAssociationPaging
> listUnfiledContainerChildren(


@ApiParam(value = "The identifier of an unfiled records container. You can use the **-unfiled-** alias.",required=true) @PathVariable("unfiledContainerId") String
 unfiledContainerId



,@Min(0)

@ApiParam(value = "The number of entities that exist in the collection before those included in this list.") @Valid @RequestParam(value = "skipCount", required = false) Integer
 skipCount




,@Min(1)

@ApiParam(value = "The maximum number of items to return in the list.") @Valid @RequestParam(value = "maxItems", required = false) Integer
 maxItems




,

@ApiParam(value = "Optionally filter the list. Here are some examples:  *   ```where=(isRecord=true)```  *   ```where=(isUnfiledRecordFolder=false)```  *   ```where=(nodeType='cm:content INCLUDESUBTYPES')``` ") @Valid @RequestParam(value = "where", required = false) String
 where




,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * aspectNames * association  * path * properties ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "Also include **source** (in addition to **entries**) with folder information on the parent node – the specified parent **unfiledContainerId**") @Valid @RequestParam(value = "includeSource", required = false) Boolean
 includeSource




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);


    @ApiOperation(value = "Update an unfiled record container", nickname = "updateUnfiledContainer", notes = "Updates unfiled record container **unfiledContainerId**. For example, you can rename an unfiled record container: ```JSON {   \"name\":\"My new name\" } ``` You can also set or update description and title properties: ```JSON {   \"properties\":     {        \"cm:description\": \"New Description\",        \"cm:title\":\"New Title\"     } } ```  **Note:** Currently there is no optimistic locking for updates, so they are applied in \"last one wins\" order. ", response = UnfiledContainerEntry.class, authorizations = {
        @Authorization(value = "basicAuth")
    }, tags={ "unfiled-containers", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful response", response = UnfiledContainerEntry.class),
        @ApiResponse(code = 400, message = "Invalid parameter: The update request is invalid or **unfiledContainerId** is not a valid format or **unfiledContainerBodyUpdate** is invalid "),
        @ApiResponse(code = 401, message = "Authentication failed"),
        @ApiResponse(code = 403, message = "Current user does not have permission to update **unfiledContainerId**"),
        @ApiResponse(code = 404, message = "**unfiledContainerId** does not exist"),
        @ApiResponse(code = 409, message = "Updated name clashes with an existing root category of special container in the current fileplan"),
        @ApiResponse(code = 422, message = "Model integrity exception, including file name with invalid characters"),
        @ApiResponse(code = 200, message = "Unexpected error", response = Error.class) })
    @RequestMapping(value = "/unfiled-containers/{unfiledContainerId}",
        produces = "application/json", 
        consumes = "application/json",
        method = RequestMethod.PUT)
    ResponseEntity<UnfiledContainerEntry
> updateUnfiledContainer(


@ApiParam(value = "The identifier of an unfiled records container. You can use the **-unfiled-** alias.",required=true) @PathVariable("unfiledContainerId") String
 unfiledContainerId



,


@ApiParam(value = "The unfiled record container information to update." ,required=true )  @Valid @RequestBody UnfiledRecordContainerBodyUpdate unfiledContainerBodyUpdate

,

@ApiParam(value = "Returns additional information about the unfiled records container's children. Any optional field from the response model can be requested. For example: * allowableOperations * path ") @Valid @RequestParam(value = "include", required = false) List<String>
 include




,

@ApiParam(value = "A list of field names.  You can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.  The list applies to a returned individual entity or entries within a collection.  If the API method also supports the **include** parameter, then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter. ") @Valid @RequestParam(value = "fields", required = false) List<String>
 fields




);

}
